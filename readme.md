# 高性能的缓存经理

---

# 获得
`go get -u github.com/zlyuancn/zcache_broker`

# 解决缓存击穿

+ 当有多个进程同时获取一个key时, 只有一个进程会真的去缓存db读取或从db加载并返回结果, 其他的进程会等待该进程结束直接收到结果.
+ 实现方式请阅读 [github.com/zlyuancn/zsingleflight](https://github.com/zlyuancn/zsingleflight)

# 解决缓存雪崩

+ 可以为命名空间设置随机的TTL, 并且可以设置该空间下的所有key每次被获取时自动刷新TTL, 可以有效减小缓存雪崩的风险

# 缓存穿透如何解决?

+ 我认为缓存穿透不是由缓存经理来解决, 而是由接收用户请求的程序来过滤这些一定不会存在的key.
+ 或许以后我们会为缓存经理添加本地内存缓存功能, 它将拥有较短的TTL, 它在同时出现大量请求同一个key(不管它是否存在)的情况下会非常有效. 但是无论如何想要减少缓存穿透的风险你都应该在用户请求key的时候判断它是否可能不存在.


# 缓存db
+ redis
+ 任何实现 zcache_broker.CacheDB 的对象

# 公开接口
###### 公开接口是用于提供数据获取的接口, 目前实现以下方案
+ grpc


# 以下是性能测试数据
```
性能测试数据即将出现
```
